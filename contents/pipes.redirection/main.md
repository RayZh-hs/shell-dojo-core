
在上一节中, 我们已经介绍了什么是管道; 简单来说, 你可以认为管道就是通过一些保留的符号，操纵命令的输入流、输出流(包括标准输出流和错误输出流）。

而我们同样提到过 Unix/Linux 设计哲学是一切都是文件(Everything is a File)，所以一个命令的输入、输出都是“文件”；既然是文件那就可以进行重定向。

---

我们先从一个范例入手感性认识一下：

```
$ pwd
/tmp/demo
$ pwd >output_file
$ ls
output_file
$ cat output_file 
/tmp/demo
```

比较第一和第二条命令，第二次的输出“消失了”，而是跑到了大于号后面文件名中。那么这里 > 就是一个重定向符。

需要注意的是, 不要轻易使用 `>` ！由于覆盖操作会不经意间清空目标文件内容！

---

一般我们能操纵的流有标准输入流 0 ，标准输出流 1 ，标准错误流 2.

重定向符也有 3 个，输入重定向符 < ，覆盖输出重定向符 > ，追加输出重定向符 >> 。

这些符号的组合方法是：

```
[n]<word   # 从文件 word 读取作为输入流到描述符[n]，默认 n=0
[n]>word   # 将描述符[n]的内容覆盖输出到文件 word，默认 n=1
[n]>>word  # 将描述符[n]的内容追加输出到文件 word，默认 n=1
&[n]       # 表示描述符[n]此刻指向的文件，而不是保持引用
```

---

对于最后一条，我们需要重点举例：

```
command 2>&1 >output_file  # 不是想要的结果！标准错误定向到了标准输出！
command >output_file 2>&1  # 正确！标准错误一起输出到了 output_file
因此有一个更好的符号是 &>word ，这语义上与 >word 2>&1 等价。
```

---

通过这样的输入输出重定向, 我们可以随心所欲的将不同的文件之间连接起来. 从 Everything is a File 的哲学看, 从管道到文件输入输出流的重定向都是十分自然的结果.
